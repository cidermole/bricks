#GeneralBricks: {
  #extends: {}
  
  # we did not put these Bricks into parts:, because ...
  # * GeneralBricks is not meant to be used as one single Brick
  # * it is awkward to write $GeneralBricks.parts.BrickName
  
  # Sentence-aligned parallel corpus.
  # This is for demo only. No real use, as it does not do any work.
  ParallelCorpus: {
    # extends: ...
    # untokenized, sentence aligned files $raw.$inputExtension, $raw.$outputExtension
    input:  { rawCorpusPrefix }
    output: { src, trg }
  }
  
  # Tokenizer
  Tokenizer: {
    input:  { raw }
    output: { tokenized }
  }
  
  # Truecaser
  Truecaser: {
    input:  { tokenized }
    output: { truecased }
  }
  
  # Preprocessor for raw corpus data, one sentence per line.
  CorpusSidePreprocessor: {
    input:  { raw }
    #output: { truecased }
    output: { truecased: $parts.Truecaser0.output.truecased }
    
    parts: {
      Tokenizer0: {
        # TODO: uh-oh. naming how when instantiating this multiple times?
        # CorpusSidePreprocessor0_Tokenizer0
        #name:    Tokenizer0
        extends: $Tokenizer
        
        # Since we should not refer to CorpusSidePreprocessor but to the final instance,
        # which is not known here yet, we must use relative paths.
        #
        # $_.key refers (explicitly) to a parent container's key.
        # Usually, container parents are walked to resolve such references implicitly
        # at the closest possible parent.
        # In this case, however, we want to avoid referring to ourselves.
        #
        input:   { raw: $_._.input.raw }
        
        # NOTE: 'in' spec is redundant semantically here, as both are just a True value
        #
        # TODO: semantics
        #
        # The semantics of this is generally difficult, as the parent 'extends'
        # must be created first (lazy eval - OK), then its parts overridden,
        # and then evaluation should be on the child instance Prep0, not here.
      }
      
      Truecaser0: {
        extends: $Truecaser
        input:   { tokenized: $Tokenizer0.output.tokenized }
      }
    }
  }
  
  Giza: {
    input:  { crp1, crp2 }
    output: { alignment }
    
    # we may either specify a shell command template directly (Jinja expanded)
    template: "[ -e input/crp1 -a -e input/crp2 ] && touch output/alignment"
    
    # or we could specify a whole Jinja template file
    #templateFile: "giza.do.jinja"
  }
  
  Symmetrizer: {
    input:  { alignment1, alignment2 }
    output: { alignment }
  }
  
  WordAligner: {
    input:  { src, trg }
    output: { alignment: $parts.Symmetrizer0.output.alignment }
    
    parts: {
      # forward GIZA++
      Giza12: {
        extends: $Giza
        input:   { crp1: $_._.input.src, crp2: $_._.input.trg }
      }
      
      # backward GIZA++
      Giza21: {
        extends: $Giza
        input:   { crp1: $_._.input.trg, crp2: $_._.input.src }
      }
      
      Symmetrizer0: {
        extends: $Symmetrizer
        input: {
          alignment1: $Giza12.output.alignment
          alignment2: $Giza21.output.alignment
        }
      }
    }
  }
#}
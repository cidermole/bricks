# Corpus text file manipulation
# =============================
# Cutting, shuffling and concatenating text.


# Limiter
# =======
# Outputs a certain amount of lines (sentences).
# input/output interface common to Head and Shuffle.
#
Limiter: {
  input:  { textFile }
  output: { head }

  # override to get leading nlines lines
  nlines
}

Head: {
  extends: $Limiter

  template: """
    {% if brick.nlines is number %}
      head -n {{ brick.nlines }} input/textFile > output/head
    {% else %}
      # use all lines
      cp input/textFile output/head
    {% endif %}
  """
}

Shuffle: {
  extends: $Limiter

  # deterministic random seed
  seed: 42

  template: """
    # deterministic random source for shuf
    # see https://www.gnu.org/software/coreutils/manual/html_node/Random-sources.html#Random-sources
    get_seeded_random() {
      seed="$1"
      openssl enc -aes-256-ctr -pass pass:"$seed" -nosalt </dev/zero 2>/dev/null
    }

    {% if brick.nlines is number %}
      shuf -n {{ brick.nlines }} --random-source=<(get_seeded_random {{ brick.seed }}) < input/textFile > output/shuffled
    {% else %}
      shuf --random-source=<(get_seeded_random {{ brick.seed }}) < input/textFile > output/shuffled
    {% endif %}
  """
}

Part: {
  extends: $Limiter

  nlinesSkip

  template: """
    {% if brick.nlines is number %}
      head -n {{ brick.nlines }} input/textFile > output/head
    {% else %}
      # use all lines
      cp input/textFile output/head
    {% endif %}

    {% if brick.nlines is number %}
      awk "NR > {{ brick.nlinesSkip }} && NR <= {{ brick.nlines + brick.nlinesSkip }}" input/textFile > output/head
    {% else %}
      awk "NR > {{ brick.nlinesSkip }}" input/textFile > output/head
    {% endif %}
  """
}

# BitextHead
# ----------
# Outputs the leading nlines of a parallel training corpus.
#
# To use all available lines, nlines may be defined without a value
# (True) or as a self-explanatory string ALL.
#
BitextHead: {
  input:  { src, trg }
  output: {
    src: $parts.HeadSrc0.output.head
    trg: $parts.HeadTrg0.output.head
  }

  nlines: ALL

  parts: {
    HeadSrc0: {
      extends: $Head
      input: { textFile: $_._.input.src }
      nlines: $_.nlines
    }
    HeadTrg0: {
      extends: $Head
      input: { textFile: $_._.input.trg }
      nlines: $_.nlines
    }
  }
}



# BitextPart
# ----------
# Outputs nlines of a parallel training corpus, starting after nlinesSkip.
#
# To use all available lines, nlines may be defined without a value
# (True) or as a self-explanatory string ALL.
#
# unused, untested.
BitextPart: {
  input:  { src, trg }
  output: {
    src: $parts.HeadSrc0.output.head
    trg: $parts.HeadTrg0.output.head
  }

  nlines: ALL
  nlinesSkip: 0

  parts: {
    HeadSrc0: {
      extends: $Head
      input: { textFile: $_._.input.src }
      nlines: $_.nlines
      nlinesSkip: $_.nlinesSkip
    }
    HeadTrg0: {
      extends: $Head
      input: { textFile: $_._.input.trg }
      nlines: $_.nlines
      nlinesSkip: $_.nlinesSkip
    }
  }
}


# Concat
# ------
# Concatenates several text corpora into one file.
#
Concat: {
  input:  { texts: [] }
  output: { concat }

  template: """
    cat{% for text in brick.input.texts %} input/texts/{{ loop.index0 }}{% endfor %} > output/concat
  """
}

# BitextConcat
# ------------
# Concatenates several parallel text corpora into one file.
#
BitextConcat: {
  input:  { sources: [], targets: [] }
  output: {
    src: $parts.ConcatSrc0.output.concat
    trg: $parts.ConcatTrg0.output.concat
  }

  parts: {
    ConcatSrc0: {
      extends: $Concat
      input:  { texts: $_._.input.sources }
    }
    ConcatTrg0: {
      extends: $Concat
      input:  { texts: $_._.input.targets }
    }
  }
}

# LineCounts
# ----------
# Outputs the length of each corpus on a separate line.
#
# unused.
LineCounts: {
  input:  { texts: [] }
  output: { countFile }

  template: """
    wc -l{% for text in brick.input.texts %} {{ text }}{% endfor %} | awk '{print $1}' | head -n-1 > output/countFile
  """
}

# Split
# -----
# Splits a single textfile into multiple lines. Uses given list of "sources" to determine line count for parts.
#
Split: {
  input: { text, sources: [] }
  # an output reference in the reverse order than is usual. (part of workaround)
  # hope this works.
  # use like below.
  # output: { texts: $_._.output.alignments }
  output: { texts: [] }

  # this is not terribly efficient, since it reads from the start for every file part.
  # can be rewritten e.g. in Python if necessary.
  template: """
    # mkdir -p output/texts  # see workaround
    iline=1
    {% for source in brick.input.sources %}
      l=$(cat {{ source }} | wc -l)
      tline=$(expr $iline + $l)
      rm -f output/texts/{{ loop.index0 }}  # remove back-symlink and replace it with a file (part of workaround)
      awk "NR >= $iline && NR < $tline" input/text > output/texts/{{ loop.index0 }}
      iline=$tline
    {% endfor %}
  """
}

# unused.
PassThrough: {
  input: { file }
  output: { file }
  template: """
    ln -sf ../input/file output/file
  """
}

# unused, untested.
# see Part.
Subset: {
  input: { text }
  output: { text }

  # one-based line indexing, inclusive range [begin, end], e.g. [1,2] returns the first two lines.
  # 'end' may use END to go till the end of the file.

  template: """
    {% if brick.end is number %}
      awk "NR >= {{ brick.begin }} && NR <= {{ brick.end }}" input/text > output/text
    {% else %}
      awk "NR >= {{ brick.begin }}" input/text > output/text
    {% endif %}
  """
}

# SplitLines
# ----------
# Splits a single textfile into multiple lines. Uses given list of line counts for parts.
#
# unused, untested.
SplitLines: {
  input: { text }
  output: { texts: [] }

  # last entry may contain END
  nlines: []

  # this is not terribly efficient, since it reads from the start for every file part.
  # can be rewritten e.g. in Python if necessary.
  template: """
    mkdir -p output/texts

    iline=1
    {# cautionary: avoid evaluating output values. (unnecesary?) #}
    {% for txt in range(brick.output.texts|length) %}
      {% if brick.nlines[loop.index0] is number %}
        l={{ brick.nlines[loop.index0] }}
      {% else %}
        l=$(expr $(cat input/text | wc -l) - $iline + 1)
      {% endif %}
      tline=$(expr $iline + $l)
      # rm -f output/texts/{{ loop.index0 }}  # remove back-symlink and replace it with a file (part of workaround)
      awk "NR >= $iline && NR < $tline" input/text > output/texts/{{ loop.index0 }}
      iline=$tline
    {% endfor %}
  """
}

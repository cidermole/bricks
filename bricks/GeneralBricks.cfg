#GeneralBricks: {
  #extends: {}
  
  # we did not put these Bricks into parts:, because ...
  # * GeneralBricks is not meant to be used as one single Brick
  # * it is awkward to write $GeneralBricks.parts.BrickName
  
  # Sentence-aligned parallel corpus.
  # This is for demo only. No real use, as it does not do any work.
  ParallelCorpus: {
    # extends: ...
    # untokenized, sentence aligned files $raw.$inputExtension, $raw.$outputExtension
    input:  { rawCorpusPrefix }
    output: { src, trg }
  }
  
  # Tokenizer
  Tokenizer: {
    input:  { raw }
    output: { tokenized }
  }
  
  # Truecaser
  Truecaser: {
    input:  { tokenized }
    output: { truecased }
  }
  
  # Preprocessor for raw corpus data, one sentence per line.
  CorpusSidePreprocessor: {
    input:  { raw }
    #output: { truecased }
    output: { truecased: $parts.Truecaser0.output.truecased }
    
    parts: {
      # The names here will be inherited if a final experiment config
      # uses Bricks extending the CorpusSidePreprocessor.
      Tokenizer0: {
        extends: $Tokenizer
        
        # Since we should not refer to CorpusSidePreprocessor but to the final instance,
        # which is not known here yet, we must use relative paths.
        #
        # $_.key refers (explicitly) to a parent container's key.
        # Usually, container ancestors are walked to resolve such references implicitly
        # at the closest possible ancestor.
        # In this case, however, we want to avoid referring to ourselves.
        #
        input:   { raw: $_._.input.raw }
      }
      
      Truecaser0: {
        extends: $Truecaser
        input:   { tokenized: $Tokenizer0.output.tokenized }
      }
    }
  }
  
  Giza: {
    input:  { side1, side2 }
    output: { alignment }
    
    # we may either specify a shell command template directly (Jinja expanded) ...
    template: "[ -e input/side1 -a -e input/side2 ] && touch output/alignment"
    
    # ... or we could specify a whole Jinja template file
    #templateFile: "giza.do.jinja"
  }
  
  Symmetrizer: {
    input:  { alignment1, alignment2 }
    output: { alignment }
  }
  
  WordAligner: {
    input:  { src, trg }
    output: { alignment: $parts.Symmetrizer0.output.alignment }
    
    parts: {
      # forward GIZA++
      Giza12: {
        extends: $Giza
        input:   { side1: $_._.input.src, side2: $_._.input.trg }
      }
      
      # backward GIZA++
      Giza21: {
        extends: $Giza
        input:   { side1: $_._.input.trg, side2: $_._.input.src }
      }
      
      Symmetrizer0: {
        extends: $Symmetrizer
        input: {
          alignment1: $Giza12.output.alignment
          alignment2: $Giza21.output.alignment
        }
      }
    }
  }
#}